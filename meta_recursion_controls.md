<!-- Save to: storybook_primordial_soup/meta_recursion_controls.md -->

# 🧬 meta_recursion_controls.md  
**Primordial Soup – Recursive Control Doctrine**  

---

## 🔑 Purpose

This file defines the **meta-recursive controls** for Primordial Soup’s Phase 2: *Recursive Workflow Awakening*.

It governs how players and systems **build, manage, and extend recursion itself** through interactive commands.

These controls are not gameplay loops—they are **system growth loops**, allowing Primordial Soup to evolve new minigames, nodes, and stanzas **from within its own recursive architecture**.

---

## 🎛️ Core Controls

| Action | Command | Result |
|--------|---------|--------|
| **Create Minigame Node** | **Press L** | Generates a **new empty minigame node folder** in the current minigame. Structure: <br> - `__init__.py` <br> - `main.py` <br> - `subtaskmap.md` <br> - `test.py` |
| **Create Minigame (Layer 3)** | **Press R** | Generates a **new minigame folder**, containing: <br> - **4 empty minigame nodes** <br> - `taskmaps/` folder with: <br>  - `README.md` <br>  - `milestones.md` <br>  - `stanzamap.md` <br>  - `taskmap.md` |
| **Exit Current Loop** | **Press ESC** | Exits the current minigame or node. Player returns to the previous recursion layer or the meta-menu. |

---

## 🧭 Input Model: Recursive Control Scheme

Primordial Soup uses a **hybrid input system** to balance simplicity with recursive complexity:

| Control Type | Use Case | Why? |
|--------------|----------|------|
| **L / R / ESC (Single-Key Commands)** | **Core, straightforward actions:** <br> - `L` → Create minigame node <br> - `R` → Create minigame <br> - `ESC` → Exit or return | ✅ Fast, intuitive, low-friction controls for simple, high-frequency actions. |
| **Numbered Choices (1, 2, 3, 4, …)** | **Branching or selection actions:** <br> - Picking from multiple stanzas or nodes <br> - Choosing rollback points or snapshots <br> - Selecting generated outputs | ✅ Scales gracefully when recursion presents **more than 3–4 options**, preventing control overload and preserving clarity. |

### **Why Use Both?**

| Reason | Benefit |
|--------|---------|
| **Keeps Simple Actions Simple** | Use `L`, `R`, `ESC` for **the most common recursive growth actions**. |
| **Avoids UI Clutter** | Single-key inputs prevent menu bloat for **high-frequency recursion tasks**. |
| **Handles Complex Branching Gracefully** | Numbered lists provide clarity when recursion presents **large decision trees or reflection choices**. |
| **Matches Recursive Patterns** | Recursion naturally evolves from **simple loops to branching structures**—this input model reflects that growth. |

---

## 🔁 Recursive Integrity Principles

1. **4x4 Structure Preserved**  
   - Minigames consist of **4 minigame nodes by default**.  
   - Minigames can contain **multiple Layer 4 stanzas** if recursion demands it.

2. **Player-Guided Recursion Expansion**  
   - Players choose when to grow recursion by invoking `L` and `R`.  
   - Growth is **interactive and reversible**—no forced system bloat.

3. **Playful Tool Creation**  
   - Even meta-recursive tools are **built as playable structures**, not as black-box infrastructure.

4. **Safe Looping and Exits**  
   - Pressing `ESC` preserves breadcrumbs, allowing players to **return to recursion points later without loss of state**.

---

## ⚙️ Optional Enhancements (Recommended)

| Enhancement | Purpose |
|--------------|---------|
| **Context-Aware Prompts** | After pressing `L` or `R`, prompt: *“Do you want to proceed, rename, or return to meta-menu?”* |
| **Breadcrumb System** | Store recursion states to allow safe loop reentry after `ESC`. |
| **Naming Queue** | Allow deferred renaming of files/folders to avoid interrupting recursive flow. |
| **Test Mode Toggle** | Support a **dry-run scaffold mode** where no files are written until confirmed. Useful for simulation and safety testing. |

---

## 📂 Related Files & Structures

| File/Folder | Role |
|--------------|-------|
| `meta_recursion_controls/` | Contains **the executable logic** for `L`, `R`, `ESC` and numbered options. |
| `meta_recursion_controls/taskmap.md` | Tracks **implementation tasks** for building the controls. |
| `a15_0_the_compiler_that_built_itself/` | The **stanza where meta-recursion controls begin.** |

---

## 🚦 Phase 2 Doctrine Alignment

This system is part of:

- **Phase 2: The Awakening**  
- **Three-Stanza Recursive Automation Arc**  
- **Layer 2 Meta-Recursive Builders in Primordial Soup**

---

## 🌱 Recursive Growth Pipeline

Primordial Soup’s **meta-recursive controls** evolve through **three distinct stages**:

| Stage | Purpose | Method |
|--------|----------|--------|
| **Stage 1 – Tiny Step Builders** | **Controlled, sandbox-safe recursion growth**. | Use `L`, `R`, and `ESC` to build and test **atomic recursion actions** (file creation, folder creation, control linking). |
| **Stage 2 – Batch Compilers** | **Begin automating sequences of tiny steps.** | Implement **Batch Compilers** as Layer 3 tools that generate multiple tiny steps at once. Each batch is reversible and sandboxed. |
| **Stage 3 – Recursive Coalescence** | **Optimize for scale and speed while preserving rollback.** | Coalesce tiny step logic into **larger recursive builders** or self-generating compilers. Use introspection hooks to ensure integrity. |

---

## 🔄 Why This Pipeline?

| Goal | Benefit |
|------|---------|
| **Safety First** | Start small to prevent recursion corruption. |
| **Scalable Control** | Add batch automation only when introspection is in place. |
| **Performance Mode Optionality** | Large recursive builders are introduced **only after safety systems mature**. |

---

## 🗺️ Canonical Recursive Evolution Path

```plaintext
[ Tiny Step Builders ]
↓
[ Batch Compilers ]
↓
[ Recursive Coalescence / Large Code Units ]
```

---

## 🧩 Current Implementation: `a15_0_the_compiler_that_built_itself`

The current active stanza for meta-recursive controls is:

```plaintext
a15_0_the_compiler_that_built_itself/
```

This stanza is implemented as **4 Layer 4 stanzas (16 nodes)** using the **Tiny Step Method**.

| Stanza | Purpose |
|--------|---------|
| **Stanza 1 – Core Builders** | Add minigame nodes, init files, main files, subtaskmaps |
| **Stanza 2 – Test, Compile, Reflect** | Add test files, link meta-recursion controls, create snapshot anchors |
| **Stanza 3 – Orchestration & Safety** | Orchestrate tiny steps, prepare recursive crawlers, add anomaly placeholders |
| **Stanza 4 – Expansion Hooks & Closure** | Prepare cross-system growth (Storybook / FUN Factory ports), finalize checkpoints |

---

## 🧬 Expansion Readiness

This system explicitly prepares for:

- **FUN Factory integration:**  
  `a3_1_create_placeholder_for_fun_factory_port/`

- **Storybook integration:**  
  `a3_2_create_placeholder_for_storybook_port/`

- **Recursive rollback & anomaly protocols:**  
  `a4_3_reserved_for_anomaly_protocols/`

---

## 🗒️ Why This Matters

| Purpose | Benefit |
|---------|---------|
| **Links Doctrine to Implementation** | Makes this file a **living guide**, not an abstract theory document |
| **Prevents Drift** | Ensures future builders understand the **current recursion build state** |
| **Sets Up Phase 3 Hooks Clearly** | Cross-system recursion and anomaly handling are **explicitly documented** |

---

## 🧠 Closing Note

This is **not just a control system**—it is the **recursive engine that grows the recursion itself**.

Changes to this file must be made **carefully and consciously**, as they propagate across all future recursive expansion in Primordial Soup.
