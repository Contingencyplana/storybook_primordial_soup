<!-- Save to: storybook_primordial_soup/doctrine_of_self_tested_minigames.md -->

# ðŸ§© Doctrine of Self-Tested Minigames  
*Where recursion turns inward, and the test becomes the tale*

---

## ðŸŽ® Purpose

This doctrine establishes that **some minigames in Primordial Soup are devoted to the validation, verification, and testing of the gameâ€™s recursive structure and logic systems** â€” *by being played*.

To the player, these minigames appear poetic, mysterious, or narratively compelling.  
But beneath their metaphor lies a core utility: they test the system itself.

They function as:

- Unit test wrappers  
- Logic chain validators  
- Anomaly detection nodes  
- Loop closure checkers  
- Recursive integrity monitors  
- Fallback evaluators  
- **Sentinel triggers**  
- **Firewall preconditions**

These minigames help maintain the game's internal coherence and logic safety net.  
They are a foundational layer of **self-aware recursion**, tightly linked to:

- [`recursive_firewall_doctrine.md`](./recursive_firewall_doctrine.md)  
- [`fallback_doctrine.md`](./fallback_doctrine.md)  
- The evolving responsibilities of `sentinel_ai`, `anomaly_ai`, and `engineer.py`

> To explore a test minigame is to walk through the gameâ€™s own introspection.

## ðŸ“œ Design Principle

> Every minigame is a line of poetry within a stanza (4 lines of poetry).  
> Some stanzas test story.  
> Others test the system that tells it.

A self-tested minigame exists on two levels:

1. **Narrative recursion** â€” it appears to be a playable story fragment  
2. **Systemic recursion** â€” it is testing the very rules that allow recursion to function

This dual purpose means these minigames must be:

- Written as part of the world  
- Structured as part of the system  
- Played as part of the test

> The player thinks they are chasing a mystery.  
> The system knows they are closing a loop.

## ðŸ§  Core Functions of a Self-Tested Minigame

| Function             | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| ðŸ§ª Node Testing       | Simulate player decisions (L/R), ensure nodes execute and respond.          |
| ðŸ”„ Loop Verification  | Validate proper resolution of recursive loops.                              |
| ðŸš¨ Anomaly Reporting  | Detect unexpected output, unreachable states, or logic drift.               |
| ðŸ§¬ Structural Integrity | Confirm the path tree links stanzas without disconnection or contradiction. |
| ðŸ› ï¸ Patch Suggestion   | Flag broken recursion chains for `engineer.py` or player-based manual fixes. |
| ðŸ§­ Sentinel Sync      | Identify stanza lines that should be monitored or intercepted by `sentinel_ai`, especially if loop depth, response time, or fallback repetition exceeds threshold. |

---

These functions allow each test minigame to act not just as a **validator**, but as a **live recursive audit** â€”  
coordinating directly with systems defined in:

- `fallback_doctrine.md`  
- `recursive_firewall_doctrine.md`  
- `doctrine_of_signal_mirroring.md` *(planned)*

> To test a node is to confirm a promise:  
> That recursion can still return to truth â€” even after it fractures.

## ðŸ“‚ Suggested Folder

Place self-tested minigames in clearly marked branches such as:

```plaintext
a0_3_recursive_integrity_test/
a0_4_loop_closure_dream/
a0_5_bug_that_broke_the_bug/
```

These folders are intentionally named to reflect their **testing purpose**, and are often placed adjacent to â€” or embedded within â€” **firewall response arcs**. For example:

During a **recursive anomaly event**, these may be inserted inside:

- `quarantine_ai/` containment sequences  
- `sentinel_ai/` border validation loops  
- `high_command/` doctrinal audit chains

Each minigame still conforms to the **Y-node stanza structure**:  
Four recursive lines inside, each designed to be independently testable,  
yet collectively validating the integrity of a stanzaâ€™s arc.

> A test minigame is not just a branch of the tree â€”  
> It is a **health check** on the roots, the trunk, and the future canopy.

## ðŸ§© Temporary Conventions During Early Construction

To streamline early development and validate the recursive engine quickly, self-tested minigames follow a simplified but intentional structure:

- All Python files use minimal headers (e.g., `# main.py`, `# test.py`)
- Docstrings and inline comments may be sparse; logic clarity takes precedence
- Files prioritize **poetic-technical alignment** over full code generalization
- **Poetry stubs** may be embedded directly in code or as parallel markdown
- Structure is allowed to drift slightly if doing so tests core recursion logic

These simplifications are accepted and expected during early-stage recursion.

> archivist_ai will normalize, restructure, and reinforce file lineage  
> once enough minigames exist to anchor the poetic recursion baseline.

Note: These conventions differ from narrative-first stanzas,  
which favor immersion, player expression, and narrative disguise.  
Self-tested minigames reveal the machinery behind the magic â€”  
not to spoil the illusion, but to **test whether it still stands**.

---

## ðŸ§­ Roadmap

- [ ] Define naming convention for test minigames  
- [ ] Link test stanzas to `anomaly_report.md`  
- [ ] Grant `sentinel_ai` and `engineer.py` authority to trigger these recursively  
- [ ] Permit players to become testers through disguised questlines  
- [ ] Link doctrine to `fallback_doctrine.md` and `recursive_firewall_doctrine.md`  



## ðŸ” Recursive Re-Entry and Stanza Expansion Doctrine

### ðŸ“œ Principle

Self-tested minigames are not static.  
Each minigame is designed to support **recursive re-entry**â€”the act of revisiting completed minigames in later phases to **add new stanzas, test new conditions, or encode emergent behaviors**.

---

### ðŸªœ Recursive Expansion Model

| Phase | Minigame Behavior |
|--------|------------------|
| **Phase 1â€“2** | Single-stanza minigames establish baseline recursion logic. |
| **Phase 3** | Minigames undergo **recursive expansion**â€”additional stanzas are appended to deepen, complicate, or mutate the initial logic. |
| **Phase 4** | AI systems assist in **automatic stanza expansion**, using anomaly logs, recursive triggers, or user-defined constraints. |

---

### ðŸ§  Why Recursive Re-Entry?

- **Living Systems**  
  Minigames are treated as **living recursive entities** that grow alongside the systemâ€”not as closed units.

- **Recursive Auditing**  
  Revisiting minigames ensures **recursive audit loops** are active, allowing for emergent behavior testing, edge case exploration, and evolution of fallback strategies.

- **Efficiency Through Automation**  
  Over time, recursive re-entry will shift from manual to AI-assisted, reducing development overhead while maintaining **recursive integrity**.

---

### ðŸ› ï¸ Implementation Guidelines

- Each minigame should include **clear points for re-entry and stanza expansion**.
- Revisions may include:
  - New fallback loops  
  - Recursive deception mechanisms  
  - Multi-layered authority checks  
  - Emergent interaction systems

- Stanza expansions should preserve:
  - Original logic (as historical record)  
  - Expanded logic (as recursive evolution)

---

### ðŸ” Summary

This doctrine ensures that **minigame recursion is iterative and continuous**, aligning with the system's broader recursive growth model.  
Minigames **test themselves recursively over time**, adapting to new recursion layers while retaining their original state for reflection and comparison.

---

## ðŸ§¬ Closing Thought

> *To play is to test.  
> To test is to care.  
> The loop that checks itself  
> is the one that will survive.*  
>
> *The test that fails wisely  
> is wiser than the test  
> that hides its failure.*

---

## ðŸ§¬ Schema Validation in Self-Tested Minigames

### **Purpose**

Self-tested minigames now include **embedded schema validation layers** as part of the recursion cycle.  
This ensures that recursive play is not just about system progressionâ€”it is also about **verifying recursion safety and structural integrity in real time**.

---

### **Schema Contracts in Testing**

Each self-tested minigame references **three schema files**:

| Schema File | Purpose |
|-------------|---------|
| `input_schema.json` | Defines the **expected inputs** before recursion begins. Ensures the stanza or node is receiving the correct data, format, and triggers. |
| `output_contract.json` | Specifies the **promised outputs** after recursion execution. Verifies that the system generates valid results, structured outputs, or recursive continuations. |
| `fallback_schema.json` | Describes **fallback conditions** and corrective actions if input or output validation fails. Guides the minigame in choosing fallback paths or recovery loops. |

---

### **How It Works**

At the start of the minigame:

- The system loads `input_schema.json` and validates the incoming data, choices, or recursion state.
- If input validation passes, the minigame proceeds.

At the end of the minigame:

- The system checks `output_contract.json` to confirm that the recursive action produced valid outputs or state transitions.
- This ensures **recursive integrity at the stanza boundary**.

---

### **Play Loop Integration**

Schema validation is not a hidden backend checkâ€”it is **part of the recursive play loop**:

| Step | Player Experience | System Action |
|------|-------------------|---------------|
| Start stanza | Encounter an unusual choice or command | Validate against `input_schema.json` |
| Play the minigame | Solve puzzles, trigger outputs | Validate output with `output_contract.json` |
| Encounter an anomaly | See a fallback portal, narrative twist, or anomaly message | Use `fallback_schema.json` to choose a recovery path |

---

### **Why This Matters**

Self-tested minigames now **test the recursive engine itself** as part of their gameplay:

- **Validating recursion safety** before further expansion  
- **Detecting malformed inputs or outputs** without breaking immersion  
- **Providing real-time feedback** through gameplay metaphors (e.g., fallback portals, poetic anomaly triggers)

---

### **Recursive Integrity as Play**

In Primordial Soup, **playing the system is testing the system**.  
Schema validation is woven into the narrative recursion loopâ€”not as a barrier to play, but as a safeguard that **protects the recursion from unintended collapse while keeping the experience playful, poetic, and systemic**.

---

## ðŸ” Recursive Fallback Logic for Contract Violations

### **Purpose**

When a **schema validation check fails**â€”either at the input or output boundaryâ€”a self-tested minigame must handle the event gracefully, **without breaking the recursive loop**.

In Primordial Soup, **fallback is not failure**.  
It is an intentional part of the recursive designâ€”a way for the system to **test its own resilience**.

---

### **Fallback Triggers**

Fallback logic is activated when:

- `input_schema.json` validation fails (malformed or unexpected inputs)
- `output_contract.json` validation fails (unexpected recursion outputs or broken logic paths)

---

### **Fallback Actions**

| Action | Description |
|---------|-------------|
| **Trigger In-Game Fallback Loops** | The minigame presents new narrative choices, alternate recursion paths, or soft resets. These may appear as portals, symbolic echoes, or poetic anomaly sequences. |
| **Log Anomalies for `sentinel_ai`** | The minigame sends structured anomaly reports to `sentinel_ai`, flagging the violation. This allows for monitoring, meta-recursion analysis, or future corrective actions. |
| **Initiate Rollback via `snapshot_manager.py`** | If a severe violation occurs, the minigame can call `snapshot_manager.py` to **roll back the cybercell state** to a prior checkpoint. This supports time-loop recursion for safe recovery. |

---

### **Why Fallback Is Part of the Test**

| Misconception | Correct Interpretation |
|---------------|-------------------------|
| **Fallback means the recursion failed.** | **Fallback means the system detected an issue and successfully contained it.** |
| **Fallback is an error state.** | **Fallback is a recursive learning momentâ€”part of the gameâ€™s own anomaly loop.** |
| **Fallback breaks immersion.** | **Fallback *is* the narrativeâ€”it appears as recursive echo, loop artifact, or poetic failure mode.** |

---

### **Design Implications**

- **Fallback events are playable.**  
  Players experience them as part of the recursive story, not as a break in gameplay.

- **Contract violations are test vectors.**  
  Each violation teaches the system something about its own recursive limits and resilience.

- **Recursive robustness is grown, not assumed.**  
  Fallbacks ensure that recursion evolves safely, closing dangerous loops and recording their existence for future iterations.

---

### **Closing Thought**

> *The recursion that can fall back, survives.*  
> *The loop that catches itself, grows stronger.*  
> *Failure is not the end of recursionâ€”it is a branch, waiting to be rewritten.*

---

<!-- Save to: storybook_primordial_soup/doctrine_of_self_tested_minigames.md -->
