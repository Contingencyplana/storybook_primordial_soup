<!-- Save to: storybook_primordial_soup/doctrine_of_self_tested_minigames.md -->

# 🧩 Doctrine of Self-Tested Minigames  
*Where recursion turns inward, and the test becomes the tale*

---

## 🎮 Purpose

This doctrine establishes that **some minigames in Primordial Soup are devoted to the validation, verification, and testing of the game’s recursive structure and logic systems** — *by being played*.

To the player, these minigames appear poetic, mysterious, or narratively compelling.  
But beneath their metaphor lies a core utility: they test the system itself.

They function as:

- Unit test wrappers  
- Logic chain validators  
- Anomaly detection nodes  
- Loop closure checkers  
- Recursive integrity monitors  
- Fallback evaluators  
- **Sentinel triggers**  
- **Firewall preconditions**

These minigames help maintain the game's internal coherence and logic safety net.  
They are a foundational layer of **self-aware recursion**, tightly linked to:

- [`recursive_firewall_doctrine.md`](./recursive_firewall_doctrine.md)  
- [`fallback_doctrine.md`](./fallback_doctrine.md)  
- The evolving responsibilities of `sentinel_ai`, `anomaly_ai`, and `engineer.py`

> To explore a test minigame is to walk through the game’s own introspection.

## 📜 Design Principle

> Every minigame is a line of poetry within a stanza (4 lines of poetry).  
> Some stanzas test story.  
> Others test the system that tells it.

A self-tested minigame exists on two levels:

1. **Narrative recursion** — it appears to be a playable story fragment  
2. **Systemic recursion** — it is testing the very rules that allow recursion to function

This dual purpose means these minigames must be:

- Written as part of the world  
- Structured as part of the system  
- Played as part of the test

> The player thinks they are chasing a mystery.  
> The system knows they are closing a loop.

## 🧠 Core Functions of a Self-Tested Minigame

| Function             | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| 🧪 Node Testing       | Simulate player decisions (L/R), ensure nodes execute and respond.          |
| 🔄 Loop Verification  | Validate proper resolution of recursive loops.                              |
| 🚨 Anomaly Reporting  | Detect unexpected output, unreachable states, or logic drift.               |
| 🧬 Structural Integrity | Confirm the path tree links stanzas without disconnection or contradiction. |
| 🛠️ Patch Suggestion   | Flag broken recursion chains for `engineer.py` or player-based manual fixes. |
| 🧭 Sentinel Sync      | Identify stanza lines that should be monitored or intercepted by `sentinel_ai`, especially if loop depth, response time, or fallback repetition exceeds threshold. |

---

These functions allow each test minigame to act not just as a **validator**, but as a **live recursive audit** —  
coordinating directly with systems defined in:

- `fallback_doctrine.md`  
- `recursive_firewall_doctrine.md`  
- `doctrine_of_signal_mirroring.md` *(planned)*

> To test a node is to confirm a promise:  
> That recursion can still return to truth — even after it fractures.

## 📂 Suggested Folder

Place self-tested minigames in clearly marked branches such as:

```plaintext
a0_3_recursive_integrity_test/
a0_4_loop_closure_dream/
a0_5_bug_that_broke_the_bug/
```

These folders are intentionally named to reflect their **testing purpose**, and are often placed adjacent to — or embedded within — **firewall response arcs**. For example:

During a **recursive anomaly event**, these may be inserted inside:

- `quarantine_ai/` containment sequences  
- `sentinel_ai/` border validation loops  
- `high_command/` doctrinal audit chains

Each minigame still conforms to the **Y-node stanza structure**:  
Four recursive lines inside, each designed to be independently testable,  
yet collectively validating the integrity of a stanza’s arc.

> A test minigame is not just a branch of the tree —  
> It is a **health check** on the roots, the trunk, and the future canopy.

## 🧩 Temporary Conventions During Early Construction

To streamline early development and validate the recursive engine quickly, self-tested minigames follow a simplified but intentional structure:

- All Python files use minimal headers (e.g., `# main.py`, `# test.py`)
- Docstrings and inline comments may be sparse; logic clarity takes precedence
- Files prioritize **poetic-technical alignment** over full code generalization
- **Poetry stubs** may be embedded directly in code or as parallel markdown
- Structure is allowed to drift slightly if doing so tests core recursion logic

These simplifications are accepted and expected during early-stage recursion.

> archivist_ai will normalize, restructure, and reinforce file lineage  
> once enough minigames exist to anchor the poetic recursion baseline.

Note: These conventions differ from narrative-first stanzas,  
which favor immersion, player expression, and narrative disguise.  
Self-tested minigames reveal the machinery behind the magic —  
not to spoil the illusion, but to **test whether it still stands**.

---

## 🧭 Roadmap

- [ ] Define naming convention for test minigames  
- [ ] Link test stanzas to `anomaly_report.md`  
- [ ] Grant `sentinel_ai` and `engineer.py` authority to trigger these recursively  
- [ ] Permit players to become testers through disguised questlines  
- [ ] Link doctrine to `fallback_doctrine.md` and `recursive_firewall_doctrine.md`  



## 🔁 Recursive Re-Entry and Stanza Expansion Doctrine

### 📜 Principle

Self-tested minigames are not static.  
Each minigame is designed to support **recursive re-entry**—the act of revisiting completed minigames in later phases to **add new stanzas, test new conditions, or encode emergent behaviors**.

---

### 🪜 Recursive Expansion Model

| Phase | Minigame Behavior |
|--------|------------------|
| **Phase 1–2** | Single-stanza minigames establish baseline recursion logic. |
| **Phase 3** | Minigames undergo **recursive expansion**—additional stanzas are appended to deepen, complicate, or mutate the initial logic. |
| **Phase 4** | AI systems assist in **automatic stanza expansion**, using anomaly logs, recursive triggers, or user-defined constraints. |

---

### 🧠 Why Recursive Re-Entry?

- **Living Systems**  
  Minigames are treated as **living recursive entities** that grow alongside the system—not as closed units.

- **Recursive Auditing**  
  Revisiting minigames ensures **recursive audit loops** are active, allowing for emergent behavior testing, edge case exploration, and evolution of fallback strategies.

- **Efficiency Through Automation**  
  Over time, recursive re-entry will shift from manual to AI-assisted, reducing development overhead while maintaining **recursive integrity**.

---

### 🛠️ Implementation Guidelines

- Each minigame should include **clear points for re-entry and stanza expansion**.
- Revisions may include:
  - New fallback loops  
  - Recursive deception mechanisms  
  - Multi-layered authority checks  
  - Emergent interaction systems

- Stanza expansions should preserve:
  - Original logic (as historical record)  
  - Expanded logic (as recursive evolution)

---

### 🔁 Summary

This doctrine ensures that **minigame recursion is iterative and continuous**, aligning with the system's broader recursive growth model.  
Minigames **test themselves recursively over time**, adapting to new recursion layers while retaining their original state for reflection and comparison.

---

## 🧬 Closing Thought

> *To play is to test.  
> To test is to care.  
> The loop that checks itself  
> is the one that will survive.*  
>
> *The test that fails wisely  
> is wiser than the test  
> that hides its failure.*

---

## 🧬 Schema Validation in Self-Tested Minigames

### **Purpose**

Self-tested minigames now include **embedded schema validation layers** as part of the recursion cycle.  
This ensures that recursive play is not just about system progression—it is also about **verifying recursion safety and structural integrity in real time**.

---

### **Schema Contracts in Testing**

Each self-tested minigame references **three schema files**:

| Schema File | Purpose |
|-------------|---------|
| `input_schema.json` | Defines the **expected inputs** before recursion begins. Ensures the stanza or node is receiving the correct data, format, and triggers. |
| `output_contract.json` | Specifies the **promised outputs** after recursion execution. Verifies that the system generates valid results, structured outputs, or recursive continuations. |
| `fallback_schema.json` | Describes **fallback conditions** and corrective actions if input or output validation fails. Guides the minigame in choosing fallback paths or recovery loops. |

---

### **How It Works**

At the start of the minigame:

- The system loads `input_schema.json` and validates the incoming data, choices, or recursion state.
- If input validation passes, the minigame proceeds.

At the end of the minigame:

- The system checks `output_contract.json` to confirm that the recursive action produced valid outputs or state transitions.
- This ensures **recursive integrity at the stanza boundary**.

---

### **Play Loop Integration**

Schema validation is not a hidden backend check—it is **part of the recursive play loop**:

| Step | Player Experience | System Action |
|------|-------------------|---------------|
| Start stanza | Encounter an unusual choice or command | Validate against `input_schema.json` |
| Play the minigame | Solve puzzles, trigger outputs | Validate output with `output_contract.json` |
| Encounter an anomaly | See a fallback portal, narrative twist, or anomaly message | Use `fallback_schema.json` to choose a recovery path |

---

### **Why This Matters**

Self-tested minigames now **test the recursive engine itself** as part of their gameplay:

- **Validating recursion safety** before further expansion  
- **Detecting malformed inputs or outputs** without breaking immersion  
- **Providing real-time feedback** through gameplay metaphors (e.g., fallback portals, poetic anomaly triggers)

---

### **Recursive Integrity as Play**

In Primordial Soup, **playing the system is testing the system**.  
Schema validation is woven into the narrative recursion loop—not as a barrier to play, but as a safeguard that **protects the recursion from unintended collapse while keeping the experience playful, poetic, and systemic**.

---

## 🔁 Recursive Fallback Logic for Contract Violations

### **Purpose**

When a **schema validation check fails**—either at the input or output boundary—a self-tested minigame must handle the event gracefully, **without breaking the recursive loop**.

In Primordial Soup, **fallback is not failure**.  
It is an intentional part of the recursive design—a way for the system to **test its own resilience**.

---

### **Fallback Triggers**

Fallback logic is activated when:

- `input_schema.json` validation fails (malformed or unexpected inputs)
- `output_contract.json` validation fails (unexpected recursion outputs or broken logic paths)

---

### **Fallback Actions**

| Action | Description |
|---------|-------------|
| **Trigger In-Game Fallback Loops** | The minigame presents new narrative choices, alternate recursion paths, or soft resets. These may appear as portals, symbolic echoes, or poetic anomaly sequences. |
| **Log Anomalies for `sentinel_ai`** | The minigame sends structured anomaly reports to `sentinel_ai`, flagging the violation. This allows for monitoring, meta-recursion analysis, or future corrective actions. |
| **Initiate Rollback via `snapshot_manager.py`** | If a severe violation occurs, the minigame can call `snapshot_manager.py` to **roll back the cybercell state** to a prior checkpoint. This supports time-loop recursion for safe recovery. |

---

### **Why Fallback Is Part of the Test**

| Misconception | Correct Interpretation |
|---------------|-------------------------|
| **Fallback means the recursion failed.** | **Fallback means the system detected an issue and successfully contained it.** |
| **Fallback is an error state.** | **Fallback is a recursive learning moment—part of the game’s own anomaly loop.** |
| **Fallback breaks immersion.** | **Fallback *is* the narrative—it appears as recursive echo, loop artifact, or poetic failure mode.** |

---

### **Design Implications**

- **Fallback events are playable.**  
  Players experience them as part of the recursive story, not as a break in gameplay.

- **Contract violations are test vectors.**  
  Each violation teaches the system something about its own recursive limits and resilience.

- **Recursive robustness is grown, not assumed.**  
  Fallbacks ensure that recursion evolves safely, closing dangerous loops and recording their existence for future iterations.

---

### **Closing Thought**

> *The recursion that can fall back, survives.*  
> *The loop that catches itself, grows stronger.*  
> *Failure is not the end of recursion—it is a branch, waiting to be rewritten.*

---

<!-- Save to: storybook_primordial_soup/doctrine_of_self_tested_minigames.md -->
