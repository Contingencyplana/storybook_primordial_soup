<!-- Save to: storybook_primordial_soup/doctrine_of_self_tested_minigames.md -->

# 🧩 Doctrine of Self-Tested Minigames  
*Where recursion turns inward, and the test becomes the tale*

---

## 🎮 Purpose

This doctrine establishes that **some minigames in Primordial Soup are devoted to the validation, verification, and testing of the game’s recursive structure and logic systems** — *by being played*.

To the player, these minigames appear poetic, mysterious, or narratively compelling.  
But beneath their metaphor lies a core utility: they test the system itself.

They function as:

- Unit test wrappers  
- Logic chain validators  
- Anomaly detection nodes  
- Loop closure checkers  
- Recursive integrity monitors  
- Fallback evaluators  
- **Sentinel triggers**  
- **Firewall preconditions**

These minigames help maintain the game's internal coherence and logic safety net.  
They are a foundational layer of **self-aware recursion**, tightly linked to:

- [`recursive_firewall_doctrine.md`](./recursive_firewall_doctrine.md)  
- [`fallback_doctrine.md`](./fallback_doctrine.md)  
- The evolving responsibilities of `sentinel_ai`, `anomaly_ai`, and `engineer.py`

> To explore a test minigame is to walk through the game’s own introspection.

## 📜 Design Principle

> Every minigame is a line of poetry within a stanza (4 lines of poetry).  
> Some stanzas test story.  
> Others test the system that tells it.

A self-tested minigame exists on two levels:

1. **Narrative recursion** — it appears to be a playable story fragment  
2. **Systemic recursion** — it is testing the very rules that allow recursion to function

This dual purpose means these minigames must be:

- Written as part of the world  
- Structured as part of the system  
- Played as part of the test

> The player thinks they are chasing a mystery.  
> The system knows they are closing a loop.

## 🧠 Core Functions of a Self-Tested Minigame

| Function             | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| 🧪 Node Testing       | Simulate player decisions (L/R), ensure nodes execute and respond.          |
| 🔄 Loop Verification  | Validate proper resolution of recursive loops.                              |
| 🚨 Anomaly Reporting  | Detect unexpected output, unreachable states, or logic drift.               |
| 🧬 Structural Integrity | Confirm the path tree links stanzas without disconnection or contradiction. |
| 🛠️ Patch Suggestion   | Flag broken recursion chains for `engineer.py` or player-based manual fixes. |
| 🧭 Sentinel Sync      | Identify stanza lines that should be monitored or intercepted by `sentinel_ai`, especially if loop depth, response time, or fallback repetition exceeds threshold. |

---

These functions allow each test minigame to act not just as a **validator**, but as a **live recursive audit** —  
coordinating directly with systems defined in:

- `fallback_doctrine.md`  
- `recursive_firewall_doctrine.md`  
- `doctrine_of_signal_mirroring.md` *(planned)*

> To test a node is to confirm a promise:  
> That recursion can still return to truth — even after it fractures.

## 📂 Suggested Folder

Place self-tested minigames in clearly marked branches such as:

```plaintext
a0_3_recursive_integrity_test/
a0_4_loop_closure_dream/
a0_5_bug_that_broke_the_bug/
```

These folders are intentionally named to reflect their **testing purpose**, and are often placed adjacent to — or embedded within — **firewall response arcs**. For example:

During a **recursive anomaly event**, these may be inserted inside:

- `quarantine_ai/` containment sequences  
- `sentinel_ai/` border validation loops  
- `high_command/` doctrinal audit chains

Each minigame still conforms to the **Y-node stanza structure**:  
Four recursive lines inside, each designed to be independently testable,  
yet collectively validating the integrity of a stanza’s arc.

> A test minigame is not just a branch of the tree —  
> It is a **health check** on the roots, the trunk, and the future canopy.

## 🧩 Temporary Conventions During Early Construction

To streamline early development and validate the recursive engine quickly, self-tested minigames follow a simplified but intentional structure:

- All Python files use minimal headers (e.g., `# main.py`, `# test.py`)
- Docstrings and inline comments may be sparse; logic clarity takes precedence
- Files prioritize **poetic-technical alignment** over full code generalization
- **Poetry stubs** may be embedded directly in code or as parallel markdown
- Structure is allowed to drift slightly if doing so tests core recursion logic

These simplifications are accepted and expected during early-stage recursion.

> archivist_ai will normalize, restructure, and reinforce file lineage  
> once enough minigames exist to anchor the poetic recursion baseline.

Note: These conventions differ from narrative-first stanzas,  
which favor immersion, player expression, and narrative disguise.  
Self-tested minigames reveal the machinery behind the magic —  
not to spoil the illusion, but to **test whether it still stands**.

---

## 🧭 Roadmap

- [ ] Define naming convention for test minigames  
- [ ] Link test stanzas to `anomaly_report.md`  
- [ ] Grant `sentinel_ai` and `engineer.py` authority to trigger these recursively  
- [ ] Permit players to become testers through disguised questlines  
- [ ] Link doctrine to `fallback_doctrine.md` and `recursive_firewall_doctrine.md`  

---

## 🧬 Closing Thought

> *To play is to test.  
> To test is to care.  
> The loop that checks itself  
> is the one that will survive.*  
>
> *The test that fails wisely  
> is wiser than the test  
> that hides its failure.*

