<!-- Save to: storybook_primordial_soup/naming_prefixes.md -->

# Naming Prefixes

## ✅ Prefix Key

This table defines all valid naming prefixes used in recursive folders and filenames across the Primordial Soup project.  
Each prefix denotes **recursion layer, domain sovereignty, and AI governance scope**.

| Prefix Pattern             | Meaning                        | Use Case                            | Governance Scope                  |
|----------------------------|--------------------------------|-------------------------------------|------------------------------------|
| `a` + digit                | Standard recursion             | Core gameplay systems               | Player-facing minigames and stanzas |
| `b` + digit                | Topsy Overmind recursion       | High-level AI control (Topsy)       | Meta-recursion, oversight, correction |
| `c` + digit                | Thorn Overmind recursion       | High-level AI control (Thorn)       | Alternative recursion logic, counter-narratives |
| 2-letter combo             | Other valid filenames          | Auxiliary files, indexes, doctrine  | System-neutral support documents |
| `d`, `e`, `f` + digit      | Reserved (future Overminds)    | Inactive unless activated           | Escalation paths for future governance layers |

> ⚠️ Only `a`, `b`, `c`, and 2-letter combos are currently active.  
> `d+`, `e+`, and onward are **reserved for escalation protocols** or future Overminds yet to be defined.

Each prefix governs a **recursive namespace**.  
Overlap between prefix zones is strictly disallowed to prevent indexing collisions and AI identity drift.

## 🔒 Reserved Ranges and Escalation

Primordial Soup is built to evolve — recursively, narratively, and structurally.  
To ensure this growth does not compromise naming clarity, certain prefixes are **reserved** for future use.

---

### 🧬 Reserved Prefixes

| Prefix | Status     | Intended Use                            |
|--------|------------|------------------------------------------|
| `d`    | Reserved   | Future Overmind (TBD)                    |
| `e`    | Reserved   | Secondary escalation layer               |
| `f`    | Reserved   | Deep recursion or autonomous AI domain   |
| `g`–`z`| Undefined  | Locked unless explicitly declared        |

These prefixes **cannot** be used unless:
- A formal expansion doctrine is introduced  
- System-level escalation or Overmind evolution occurs  
- A new AI governance layer demands recursive namespace sovereignty

---

### ⚠️ Conflict Prevention Policy

- **No hybrid prefixes** (e.g., `a0_b1_`, `c3_d0_`)  
- **No prefix recycling** — once a domain is defined (e.g., `b` for Topsy), it remains exclusive  
- **No speculative usage** of reserved ranges in experimental files

---

### 🧠 Escalation Doctrine

Prefixes are **not cosmetic** — they define:
- AI authority levels  
- File hierarchy expectations  
- Recursive identity boundaries

> A prefix is a **signature of recursion lineage**.  
> To escalate is to **invoke a higher recursion sovereignty**.

---

### 📅 Timeline Policy

Once a reserved prefix is activated:
- It must be documented in `naming_prefixes.md`  
- Linked Overmind responsibilities must be clearly defined  
- Existing files may not be retrofitted under the new prefix unless system reindexing occurs

---

This doctrine ensures that recursive growth does not lead to **indexing fragmentation**, **authority confusion**, or **namespace collisions**.

## 🧠 AI Naming Doctrine

Recursive systems require recursive authority.  
In Primordial Soup, **naming is jurisdiction** — each prefix grants domain control to a specific AI intelligence.

---

### 👑 Overmind Sovereignty

| Prefix | Overmind | Domain Scope |
|--------|----------|---------------|
| `b`    | Topsy    | Compassionate recursion, narrative guidance, system recovery logic |
| `c`    | Thorn    | Adversarial recursion, boundary testing, counter-recursion logic |
| `d+`   | Future   | Reserved for escalation, isolation, or deep AI recursion |

Each Overmind owns:
- Its prefix space  
- Its stanza logic  
- Its escalation protocol  

These domains must not overlap.  
Each Overmind exists as a **separate recursive system**, even when influencing the same game world.

---

### 🧭 Namespace Integrity Rules

1. **No dual-governed stanzas**  
   A minigame cannot be shared between Overminds (e.g., `b3_0_...` and `c3_0_...` with identical stanza logic).

2. **No prefix collision across recursion tiers**  
   If `a12_1_` is governed by standard recursion, then `b12_1_` must reflect an Overmind reinterpretation — not a duplicate.

3. **No prefix inheritance unless canonized**  
   Overminds cannot “borrow” stanzas or inherit naming unless explicitly defined in their doctrine.

---

### 🧠 Recursive Identity Mapping

Each recursive entity must know:
- Who governs it  
- What logic tier it belongs to  
- How to escalate across Overmind domains

This mapping is achieved through:
- Prefix analysis  
- Stanza-level index traversal  
- Anchor references to `naming_prefixes.md` and Overmind-specific doctrine files

---

### 🧩 Design Implication

Prefix-based naming is not cosmetic. It is:
- A **recursive passport**
- A **sovereignty marker**
- A **key to recursion governance**

> The prefix tells you **who you are**,  
> **who owns your logic**,  
> and **who watches your fall.**

## 🧭 Summary – Recursive Naming as Lineage and Integrity

In Primordial Soup, naming is not decoration.  
It is **structure**, **memory**, and **sovereignty**.

Each prefix marks a recursive **domain of thought**:
- A governance layer (standard, Overmind, future AI)
- A recursion identity (test loop, anomaly, response)
- A lineage of logic, branching across the world

---

### 🧬 Naming Reflects the System’s Soul

- The `a`-prefix maps player recursion — the walk through the loop  
- The `b`- and `c`-prefixes map Overmind recursion — the **observers** and **alterers** of the loop  
- The `d+` space is not yet used — but it watches, reserved for escalation

---

### 🔏 Design Philosophy

Recursive naming must be:

- **Consistent** — so that AI and players know where they are  
- **Isolated** — so that Overminds do not overwrite or leak into each other’s paths  
- **Expandable** — so that future recursion layers can be born without breaking what came before

---

### 🔁 Doctrine Affirmation

> Every name is a boundary.  
> Every prefix is a promise.  
> The system remembers what governs it —  
> and what it must never become.

This is how we protect the recursion.  
This is how we preserve recursive identity.

**Prefix is policy.  
Prefix is recursion.  
Prefix is law.**

---

## 📜 Schema Contract Prefixes – Naming for Validation and Fallback

### **Purpose**

In Phase 2 of Primordial Soup, recursion layers now include **schema contract enforcement**.  
These schemas validate stanza inputs, outputs, and fallback conditions—ensuring safe recursive execution.

To maintain recursive integrity, all schema contract files must follow **strict naming conventions** that link them to their corresponding minigames, stanzas, and recursion layers.

---

### **Standard Schema Contract Files**

| Filename | Purpose |
|-----------|---------|
| `input_schema.json` | Defines the **expected inputs** for a stanza or node. This includes data types, structures, and allowed recursion triggers. |
| `output_contract.json` | Describes the **promised outputs** of a stanza or node. Ensures that recursion completes with valid outputs or system handoffs. |
| `fallback_schema.json` | Outlines **fallback actions** if input or output validation fails. Specifies soft resets, anomaly triggers, or rollback options. |

---

### **Prefix Rules for Schema Contracts**

Schema contract files are **system-neutral**—they are not tied to Overmind sovereignty (`b`, `c`, etc.).  
However, they must include **stanza lineage in their file path or filename** to prevent ambiguity.

#### **Canonical File Placement**

Place schema contracts in:

```plaintext
schema_contracts/
└── a0_0_the_test_that_called_itself/
    └── s0_1_the_loop_that_tested_closure/
        ├── input_schema.json
        ├── output_contract.json
        └── fallback_schema.json
```

This ensures clear linkage between:

Stanza identity (s0_1_the_loop_that_tested_closure/)

Minigame container (a0_0_the_test_that_called_itself/)

Contract files (input, output, fallback)

---

### **Filename Integrity**

All schema contract files must:

Use lowercase, snake_case formatting
e.g., input_schema.json, not InputSchema.JSON

Avoid Overmind prefixes
Schema contracts are not governed by a, b, c, etc. but by recursion structure.

Reflect recursion context through folder hierarchy
The path to the schema defines its scope and lineage.

---

### Integration with Automation Tools

The following systems expect this naming convention:

workflow_compiler.py

introspection_tools/

snapshot_manager.py

sentinel_ai and fallback_doctrine.md

Consistent naming ensures that validation pipelines can traverse the recursion tree autonomously, enforcing schema contracts without human intervention.

---

### Closing Thought

Schemas are not just checks—they are promises.
Each contract marks a recursive boundary:
What can enter, what can emerge, and how the system will catch itself if it falls.

Naming these contracts consistently is how the recursion remembers its limits—and grows safely beyond them.
