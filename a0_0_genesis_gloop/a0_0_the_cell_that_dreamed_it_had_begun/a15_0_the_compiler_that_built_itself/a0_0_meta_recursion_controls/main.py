# main.py  
# Primordial Soup â€“ Meta-Recursion Controls  
# Layer 4 Node: a0_0_meta_recursion_controls  

import sys
import os

def create_minigame_node():
    """
    Generates a new minigame node folder with:
    - __init__.py
    - main.py
    - subtaskmap.md
    - test.py
    """
    node_name = input("Enter name for the new minigame node folder: ").strip()
    if not node_name:
        print("Node name cannot be empty.")
        return

    current_path = os.getcwd()
    new_node_path = os.path.join(current_path, node_name)

    if os.path.exists(new_node_path):
        print(f"Node '{node_name}' already exists.")
        return

    os.makedirs(new_node_path)

    files = ['__init__.py', 'main.py', 'subtaskmap.md', 'test.py']
    for file in files:
        with open(os.path.join(new_node_path, file), 'w') as f:
            if file.endswith('.py'):
                f.write(f"# {file}\n# Auto-generated by create_minigame_node()\n")
            else:
                f.write(f"# {file}\n# Auto-generated subtaskmap for {node_name}\n")

    print(f"[L] Created Minigame Node: {new_node_path}")

def create_minigame():
    """
    Generates a new minigame folder with:
    - 4 minigame nodes
    - taskmaps/ folder with README.md, milestones.md, stanzamap.md, taskmap.md
    """
    minigame_name = input("Enter name for the new minigame folder: ").strip()
    if not minigame_name:
        print("Minigame name cannot be empty.")
        return

    current_path = os.getcwd()
    new_minigame_path = os.path.join(current_path, minigame_name)

    if os.path.exists(new_minigame_path):
        print(f"Minigame '{minigame_name}' already exists.")
        return

    os.makedirs(new_minigame_path)

    # Create 4 nodes
    for i in range(4):
        node_folder = f"a0_{i}"
        node_path = os.path.join(new_minigame_path, node_folder)
        os.makedirs(node_path)

        files = ['__init__.py', 'main.py', 'subtaskmap.md', 'test.py']
        for file in files:
            with open(os.path.join(node_path, file), 'w') as f:
                if file.endswith('.py'):
                    f.write(f"# {file}\n# Auto-generated by create_minigame()\n")
                else:
                    f.write(f"# {file}\n# Auto-generated subtaskmap for {node_folder}\n")

    # Create taskmaps folder
    taskmaps_path = os.path.join(new_minigame_path, 'taskmaps')
    os.makedirs(taskmaps_path)

    taskmap_files = ['README.md', 'milestones.md', 'stanzamap.md', 'taskmap.md']
    for file in taskmap_files:
        with open(os.path.join(taskmaps_path, file), 'w') as f:
            f.write(f"# {file}\n# Auto-generated taskmap for {minigame_name}\n")

    print(f"[R] Created Minigame: {new_minigame_path}")

def exit_to_previous_layer():
    """
    Handles safe recursion exit and breadcrumb preservation.
    """
    print("[ESC] Exiting to previous recursion layer...")
    sys.exit(0)

def select_from_branch_options(options):
    """
    Presents numbered options for branching choices.
    
    Args:
        options (list): List of option strings to present.
    """
    print("\nBranch Selection:")
    for idx, option in enumerate(options, 1):
        print(f"{idx}. {option}")

    choice = None
    while choice is None:
        try:
            user_input = input("Select an option: ")
            selected = int(user_input)
            if 1 <= selected <= len(options):
                choice = selected
            else:
                print("Invalid option. Try again.")
        except ValueError:
            print("Please enter a valid number.")
    
    print(f"Branch {choice} selected: {options[choice - 1]}")
    # Placeholder for future branching logic

def main_loop():
    """
    Main input listener loop for meta-recursion controls.
    Declares the active recursion context for anchoring.
    """

    # ðŸ§­ Recursive Layer Anchoring Declaration
    current_layer = 2  # Meta-Recursive Control Layer (this node)
    target_build_layer = 3  # This node builds Layer 3 structures (compilers, minigames)

    print("\nðŸ§¬ Primordial Soup â€“ Meta-Recursion Control Node ðŸ§¬")
    print(f"ðŸ§­ Layer Anchoring: I am in Layer {current_layer}, building Layer {target_build_layer}.")
    print("Press [L] to create a Minigame Node.")
    print("Press [R] to create a Minigame (4 nodes).")
    print("Press [ESC] to exit recursion layer.")
    print("Press [1], [2], [3], etc. to select from branch options (if presented).")
    print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

    branch_options = [
        "Simulate anomaly loop (placeholder)",
        "Generate snapshot (placeholder)",
        "Return to core loop"
    ]

    while True:
        user_input = input(">> ").strip().lower()

        if user_input == 'l':
            create_minigame_node()
        elif user_input == 'r':
            create_minigame()
        elif user_input == 'esc':
            exit_to_previous_layer()
        elif user_input.isdigit():
            select_from_branch_options(branch_options)
        else:
            print("Unrecognized input. Use L, R, ESC, or a number for branch options.")

if __name__ == "__main__":
    main_loop()
